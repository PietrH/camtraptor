% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_predicates.R
\name{filter_predicate}
\alias{filter_predicate}
\alias{pred_primitive}
\alias{pred}
\alias{pred_not}
\alias{pred_gt}
\alias{pred_gte}
\alias{pred_lt}
\alias{pred_lte}
\alias{pred_in}
\alias{pred_notin}
\alias{pred_na}
\alias{pred_notna}
\alias{pred_and}
\alias{pred_or}
\title{Filter predicate}
\usage{
pred_primitive(arg, value, symbol, type)

pred(arg, value)

pred_not(arg, value)

pred_gt(arg, value)

pred_gte(arg, value)

pred_lt(arg, value)

pred_lte(arg, value)

pred_in(arg, value)

pred_notin(arg, value)

pred_na(arg)

pred_notna(arg)

pred_and(...)

pred_or(...)
}
\arguments{
\item{value}{(various) the value for the predicate}

\item{..., .list}{For \code{pred_or()} or \code{pred_and()}, one or more objects of
class \code{filter_predicate}, created by any \verb{pred*} function}

\item{key}{(character) the key for the predicate. See "Keys" below}
}
\description{
Filter predicate
}
\section{predicate methods and their equivalent types}{


\verb{pred*} functions are named for the 'type' of operation they do, inspired  by
GBIF \href{https://www.gbif.org/developer/occurrence#predicates}{occurrence predicates}

The following functions take one key and one value:
\itemize{
\item \code{pred}: equals
\item \code{pred_lt}: lessThan
\item \code{pred_lte}: lessThanOrEquals
\item \code{pred_gt}: greaterThan
\item \code{pred_gte}: greaterThanOrEquals
\item \code{pred_like}: like (NOT IMPLEMENTED YET!)
}

The following function is only for geospatial queries, and only
accepts a WKT string:
\itemize{
\item \code{pred_within}: within (NOT IMPLEMENTED YET!)
}

The following functions are only for stating that you do (not) want
a key to be NA, so only accepts one key:
\itemize{
\item \code{pred_na}: isNA
\item \code{pred_notna}: isNotNA
}

The following two functions accept multiple individual predicates,
separating them by either "and" or "or":
\itemize{
\item \code{pred_and}: and
\item \code{pred_or}: or
}

The not predicate accepts one predicate; that is, this negates whatever
predicate is passed in, e.g., not the location "B_ML_val 05_molenkreek":
\itemize{
\item \code{pred_not}: not
}

The following function is special in that it accepts a single key but many
values, stating that you want to search for all the listed values, e.g.
one of the locations in: "B_ML_val 05_molenkreek", "B_ML_val 03_De Val" and
"B_ML_val 06_Oostpolderkreek"
\itemize{
\item \code{pred_in}: in
}
}

\section{What happens internally}{

Internally, the input to \verb{pred*} functions turns into a character string.
For example ...

\code{pred("tags", "boven de stroom")} gives:\preformatted{(tags == "boven de stroom")

}

\code{pred_gt("latitude", 51.27)} gives:\preformatted{(latitude > 51.27)
}

\code{pred_or()} gives:\preformatted{((tags == "boven de stroom") | (latitude > 51.28))
}

\code{pred_or()} gives:\preformatted{((tags == "boven de stroom") & (latitude > 51.28))
}
}

\section{Keys}{


Acceptable arguments to the \code{key} parameter are the column names of the
data.frame you are applying the filter predicates.
}

\examples{
# one arg one value predicates
pred("scientific_name", "Anas platyrhynchos")
pred("tags", "boven de stroom")
pred_gt("latitude", 51.28)
pred_gte("latitude", 51.28)
pred_lt("longitude", 3.59)
pred_lte("longitude", 3.59)
pred_not("location_name", "B_ML_val 03_De Val")

# and, or predicates
pred_and(pred_lt("longitude", 3.59),pred_gt("latitude", 51.28))
pred_or(pred_gte("count", 2), pred("vernacular_name", "Norway Rat"))

# use Dates as argument
start_date <- as.Date("2020-06-03", format = "\%Y-\%m-\%d")
end_date <- as.Date("2020-06-10", format = "\%Y-\%m-\%d")
pred_or(pred_gte("start", start_date), pred_lte("end", end_date))

# use datetimes (POSIXct) as argument
start_date <- lubridate::as_datetime("2020-06-03")
end_date <- lubridate::as_datetime("2020-06-10")
pred_or(pred_gte("start", start_date), pred_lte("end", end_date))

# one arg multiple values predicates
locations <- c("B_ML_val 03_De Val", "B_ML_val 05_molenkreek")
pred_in("location_name", locations)
pred_notin("location_name", locations)
start_dates <- as_datetime(c("2020-06-03 20:10:18","2020-06-03 20:04:33"))
pred_in("start", start_dates)
pred_notin("start", start_dates)

# one arg, no value predicates
pred_na("scientific_name")
pred_notna("scientific_name")

}
\concept{get_functions}
