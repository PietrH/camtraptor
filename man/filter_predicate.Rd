% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_predicates.R
\name{filter_predicate}
\alias{filter_predicate}
\alias{pred}
\alias{pred_not}
\alias{pred_gt}
\alias{pred_gte}
\alias{pred_lt}
\alias{pred_lte}
\alias{pred_in}
\alias{pred_notin}
\alias{pred_na}
\alias{pred_notna}
\alias{pred_and}
\alias{pred_or}
\title{Filter predicate}
\usage{
pred(arg, value)

pred_not(arg, value)

pred_gt(arg, value)

pred_gte(arg, value)

pred_lt(arg, value)

pred_lte(arg, value)

pred_in(arg, value)

pred_notin(arg, value)

pred_na(arg)

pred_notna(arg)

pred_and(...)

pred_or(...)
}
\arguments{
\item{arg}{(character) the key for the predicate. See "Keys" below}

\item{value}{(various) the value for the predicate}

\item{...}{for \code{pred_or()} or \code{pred_and()}: one or more objects of
class \code{filter_predicate}, created by any other \verb{pred*} function}
}
\value{
a predicate object. An object of class predicate is a list with the
following slots:
\enumerate{
\item \code{arg}: a (list of) character with all arguments in the predicate(s)
\item \code{value}:  a (list of) character with all values in the predicate(s)
\item \code{type}:  a (list of) character with all predicate types, see section
"predicate methods" here below
\item \code{expr}: a character: body of a filter expression
}
}
\description{
Filter predicate
}
\section{Predicate methods and their equivalent types}{


\verb{pred*} functions are named for the 'type' of operation they do, inspired  by
GBIF \href{https://www.gbif.org/developer/occurrence#predicates}{occurrence predicates}

The following functions take one key and one value and are associated to the
following types:
\itemize{
\item \code{pred}: equals
\item \code{pred_not}: notEquals
\item \code{pred_lt}: lessThan
\item \code{pred_lte}: lessThanOrEquals
\item \code{pred_gt}: greaterThan
\item \code{pred_gte}: greaterThanOrEquals
\item \code{pred_like}: like (NOT IMPLEMENTED YET!)
}

The following function is only for geospatial queries, and only
accepts a WKT string:
\itemize{
\item \code{pred_within}: within (NOT IMPLEMENTED YET!)
}

The following functions are only for stating that you do (not) want
a key to be NA, so only accepts one key:
\itemize{
\item \code{pred_na}: isNA
\item \code{pred_notna}: isNotNA
}

The following two functions accept multiple individual filter predicates,
separating them by either "and" or "or":
\itemize{
\item \code{pred_and}: and
\item \code{pred_or}: or
}

The following function is special in that it accepts a single key but many
values, stating that you want to search for all the listed values, e.g.
one of the locations in: "B_ML_val 05_molenkreek", "B_ML_val 03_De Val" and
"B_ML_val 06_Oostpolderkreek"
\itemize{
\item \code{pred_in}: in
\item \code{pred_notin}: notIn
}
}

\section{What happens internally}{


Internally, the input to \verb{pred*} functions turn into a character string,
which forms the body of a filter expression.
For example:

\code{pred("tags", "boven de stroom")} gives:\preformatted{$arg
[1] "tags"

$value
[1] "boven de stroom"

$type
[1] "equals"

$expr
(tags == "boven de stroom")

}

\code{pred_gt("latitude", 51.27)} gives, (only \code{expr} slot shown):\preformatted{(latitude > 51.27)
}

\code{pred_or()} gives:\preformatted{((tags == "boven de stroom") | (latitude > 51.28))
}

\code{pred_or()} gives:\preformatted{((tags == "boven de stroom") & (latitude > 51.28))
}
}

\section{Keys}{


Acceptable arguments to the \code{key} parameter are the column names of the
data.frame you are applying the filter predicates.
}

\examples{
# one arg one value predicates
pred("scientificName", "Anas platyrhynchos")
pred("tags", "boven de stroom")
pred_gt("latitude", 51.18)
pred_gte("latitude", 51.18)
pred_lt("longitude", 3.95)
pred_lte("longitude", 3.95)
pred_not("locationName", "B_DL_val 3_dikke boom")

# and, or predicates
pred_and(pred_lt("longitude", 3.59), pred_gt("latitude", 51.28))
pred_or(pred_gte("count", 2), pred("vernacular_name", "Norway Rat"))

# use Dates as argument
start_date <- as.Date("2020-06-03", format = "\%Y-\%m-\%d")
end_date <- as.Date("2020-06-10", format = "\%Y-\%m-\%d")
pred_or(pred_gte("start", start_date), pred_lte("end", end_date))

# use datetimes (POSIXct) as argument
start_date <- lubridate::as_datetime("2020-06-03")
end_date <- lubridate::as_datetime("2020-06-10")
pred_or(pred_gte("start", start_date), pred_lte("end", end_date))

# one arg multiple values predicates
locations <- c("B_ML_val 03_De Val", "B_ML_val 05_molenkreek")
pred_in("location_name", locations)
pred_notin("location_name", locations)
start_dates <- lubridate::as_datetime(c("2020-06-03 20:10:18","2020-06-03 20:04:33"))
pred_in("start", start_dates)
pred_notin("start", start_dates)

# one arg, no value predicates
pred_na("scientificName")
pred_notna("scientificName")
}
\seealso{
Other get_functions: 
\code{\link{get_custom_effort}()},
\code{\link{get_effort}()}
}
\concept{get_functions}
